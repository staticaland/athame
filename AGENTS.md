# Dagger Development Guidelines

## Monorepo Structure

This is a Dagger monorepo where we create and manage multiple Dagger modules, always using the Go SDK.

### Creating New Modules

To create a new module, use:

```bash
dagger init --sdk=go --name=<module-name>
```

Example:
```bash
dagger init --sdk=go --name=basics
```

Command format: `dagger init [options] [path]`

### Using Modules

To use a module in your project, use the `dagger install` command:

```bash
dagger install [options] <module>
```

### Directory Structure

- **`.dagger/`** - Optional orchestration module. Use `dagger install` here to compose multiple modules, or create dedicated wrapper modules elsewhere. Project CI may also live here.
- **Individual module directories** - Each module lives in its own directory at the repo root.

## Import Path

Always import Dagger from:
```go
import "dagger/<module-name>/internal/dagger"
```

Replace `<module-name>` with your actual module name.

## Generated Files - Do Not Edit

These files are auto-generated by Dagger and should never be manually edited:

- `dagger.gen.go`
- `internal/` directory

## Constructors

Use the `func New()` pattern when multiple functions need the same parameters.

### When to Use

- **Shared configuration** - parameters used across multiple functions
- **Module-wide state** - avoid repeating the same parameters in every function

### Requirements

- **Public fields only** - capitalize field names in Go (e.g., `Greeting`, `Name`) for proper serialization
- **One constructor per module** - Dagger modules have only one constructor
- **Return module pointer** - return `*YourModule` from `New()`

### Example

```go
func New(
    // +default="https://api.example.com"
    apiUrl string,
    // +optional
    apiKey string,
) *MyModule {
    return &MyModule{
        ApiUrl: apiUrl,
        ApiKey: apiKey,
    }
}

type MyModule struct {
    ApiUrl string
    ApiKey string
}

func (m *MyModule) GetUser(id string) (*User, error) {
    // Use m.ApiUrl and m.ApiKey without passing them as parameters
}

func (m *MyModule) CreateUser(name string) (*User, error) {
    // Same fields available here
}
```

## Base Function

All modules should provide a `Base()` function that returns a configured base container.

### Purpose

- **Container foundation** - provides a reusable base container with runtime image and dependencies
- **Shared setup** - other module functions build on top of this base
- **Cache optimization** - centralizes cache volume configuration

### Requirements

- **Always use image digests** - never use tags alone (e.g., `node:lts-alpine`)
- **Use crane for digests** - run `crane ls` and `crane digest` to get the latest digest
- **Add renovate comments** - enable automated dependency updates

### Example

```go
// Base returns the base container with runtime and dependencies installed
func (m *MyModule) Base() *dagger.Container {
    // renovate: datasource=docker depName=node
    ctr := dag.Container().
        From("node:lts-alpine@sha256:...").
        WithoutEntrypoint().
        WithMountedDirectory("/src", m.Src).
        WithWorkdir("/src")

    if !m.DisableCache {
        ctr = ctr.
            WithMountedCache(
                "/root/.npm/_cacache",
                dag.CacheVolume("npm-cache"),
                dagger.ContainerWithMountedCacheOpts{
                    Sharing: dagger.CacheSharingModePrivate,
                },
            )
    }

    return ctr
}
```

### Finding Image Digests

```bash
# List available tags
crane ls node

# Get digest for specific tag
crane digest node:lts-alpine
```

## Function Parameters

Use Dagger annotations for parameter handling:

- `+default="value"` - for parameters with default values
- `+optional` - for parameters that can be omitted

### Required Patterns

- **Use annotations exclusively** - let Dagger handle defaults, not your function body
- **Trust the framework** - write functions assuming defaults are already applied
- **Document well** - add descriptive comments for optional parameters

### Forbidden Patterns

- **No manual checks** - don't use `if param == ""` for parameters with `+default` annotations
- **No defensive logic** - avoid conditional logic for optional parameters unless your business logic requires it
- **No mixing approaches** - don't combine annotations with manual default handling

## Example

```go
// Deploy runs the deployment process
// +optional
func (m *MyModule) Deploy(
    // +default="production"
    environment string,
    // +optional
    dryRun bool,
) error {
    // Function body assumes defaults are already applied
    // No need for: if environment == "" { environment = "production" }
}
```
