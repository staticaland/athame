# Dagger Development Guidelines

## Monorepo Structure

This is a Dagger monorepo where we create and manage multiple Dagger modules, always using the Go SDK.

### Creating New Modules

To create a new module, use:

```bash
dagger init --sdk=go --name=<module-name> <module-name>
```

Example:

```bash
dagger init --sdk=go --name=basics basics
```

Command format: `dagger init [options] [path]`

### Using Modules

To use a module in your project, use the `dagger install` command:

```bash
dagger install [options] <module>
```

### Exploring Modules

Before using a module, explore its available functions to understand its API:

```bash
dagger functions -m <module-path>
```

Example:

```bash
dagger functions -m ./terraform-docs
```

This shows all available functions, their parameters, and return types. Always check what functions exist before implementing - don't assume method names or signatures.

### Exporting Results

To export files or directories from Dagger functions to your local filesystem, use the `export` command:

```bash
dagger call <function-name> export --path=<local-path>
```

Example with terraform-docs module:

```bash
dagger call -m terraform-docs base export --path=.
```

This exports the directory returned by `base` to the current directory (`.`).

### Directory Structure

- **`.dagger/`** - Optional orchestration module. Use `dagger install` here to compose multiple modules, or create dedicated wrapper modules elsewhere. Project CI may also live here.
- **Individual module directories** - Each module lives in its own directory at the repo root.

## Import Path

Always import Dagger from:

```go
import "dagger/<module-name>/internal/dagger"
```

Replace `<module-name>` with your actual module name.

## Generated Files - Do Not Edit

These files are auto-generated by Dagger and should never be manually edited or read:

- `dagger.gen.go`
- `internal/` directory

## Constructors

Use the `func New()` pattern when multiple functions need the same parameters.

### When to Use

- **Shared configuration** - parameters used across multiple functions
- **Module-wide state** - avoid repeating the same parameters in every function

### Requirements

- **Public fields only** - capitalize field names in Go (e.g., `Greeting`, `Name`) for proper serialization
- **One constructor per module** - Dagger modules have only one constructor
- **Return module pointer** - return `*YourModule` from `New()`

### Container Image Configuration

**All modules that wrap a container image MUST configure the image reference via an `imageTag` parameter in the constructor.**

This is the standard pattern across all modules in this repository.

### Pattern

- **Always use imageTag parameter** - every container-based module constructor must have this parameter
- **Store version+digest** - use `version@sha256:digest` format (never use tags alone)
- **Add renovate comment** - place above the parameter for automated dependency updates
- **Store in struct** - add `ImageTag string` field to your module struct
- **Use in Base()** - construct full image reference with `fmt.Sprintf("image:%s", m.ImageTag)`

### Example

```go
func New(
    // renovate: datasource=docker depName=hashicorp/terraform
    // +default="1.13.4@sha256:eebc943e69008b6d6d986800087164274d8c92d83db8d53fb9baa4ccff309884"
    imageTag string,
) *Terraform {
    return &Terraform{
        ImageTag: imageTag,
    }
}

type Terraform struct {
    ImageTag string
}

// Base returns the base container with Terraform installed
func (m *Terraform) Base() *dagger.Container {
    return dag.Container().
        From(fmt.Sprintf("hashicorp/terraform:%s", m.ImageTag)).
        WithoutEntrypoint()
}
```

### General Constructor Example

```go
func New(
    // +default="https://api.example.com"
    apiUrl string,
    // +optional
    apiKey string,
) *MyModule {
    return &MyModule{
        ApiUrl: apiUrl,
        ApiKey: apiKey,
    }
}

type MyModule struct {
    ApiUrl string
    ApiKey string
}

func (m *MyModule) GetUser(id string) (*User, error) {
    // Use m.ApiUrl and m.ApiKey without passing them as parameters
}

func (m *MyModule) CreateUser(name string) (*User, error) {
    // Same fields available here
}
```

## Base Function

All modules should provide a `Base()` function that returns a configured base container.

### Purpose

- **Container foundation** - provides a reusable base container with runtime image and dependencies
- **Shared setup** - other module functions build on top of this base
- **Cache optimization** - centralizes cache volume configuration

### Requirements

- **Always use image digests** - never use tags alone (e.g., `node:lts-alpine`)
- **Prefer specific version tags** - use fully qualified versions including base OS version when available (e.g., `20.11.1-alpine3.19` over `20.11.1-alpine`). This clarifies why digests change.
- **Use crane for digests** - run `crane ls` and `crane digest` in an agent to get the latest digest
- **Add renovate comments** - enable automated dependency updates

### Example

```go
// Base returns the base container with runtime and dependencies installed
func (m *MyModule) Base() *dagger.Container {
    return dag.Container().
        // renovate: datasource=docker depName=node
        From("node:20.11.1-alpine3.19@sha256:...").
        WithoutEntrypoint().
        WithMountedDirectory("/src", m.Src).
        WithWorkdir("/src")
}
```

### Finding Image Digests

Use the `Task` tool when running `crane` to find the latest version and image digest:

```bash
# Find the latest stable version using version sort
# Use tail -n 50 to see recent versions and pick the latest stable
crane ls hashicorp/terraform | sort --version-sort | tail -n 50

# Get digest for the selected tag
crane digest hashicorp/terraform:1.13.4
```

## Function Parameters

Use Dagger annotations for parameter handling:

- `+default="value"` - for parameters with default values
- `+optional` - for parameters that can be omitted

### Required Patterns

- **Use annotations exclusively** - let Dagger handle defaults, not your function body
- **Trust the framework** - write functions assuming defaults are already applied
- **Document well** - add descriptive comments for optional parameters

### Forbidden Patterns

- **No manual checks** - don't use `if param == ""` for parameters with `+default` annotations
- **No defensive logic** - avoid conditional logic for optional parameters unless your business logic requires it
- **No mixing approaches** - don't combine annotations with manual default handling

### Directory Parameters

For functions that work with repository source code, use `+defaultPath` to automatically resolve directory paths.

#### Path Resolution in Git Repositories

- **Absolute paths** (`/`, `/src`) - resolve from repository root
- **Relative path** (`.`) - resolves to the directory containing `dagger.json`
- **Parent path** (`..`) - resolves to parent of the directory containing `dagger.json`

#### Pattern

Use `+defaultPath="/"` for modules that should work with the entire repository by default:

```go
func (m *MyModule) ReadDir(
    ctx context.Context,
    // +defaultPath="/"
    source *dagger.Directory,
) ([]string, error) {
    return source.Entries(ctx)
}
```

## Example

```go
// Deploy runs the deployment process
// +optional
func (m *MyModule) Deploy(
    // +default="production"
    environment string,
    // +optional
    dryRun bool,
) error {
    // Function body assumes defaults are already applied
    // No need for: if environment == "" { environment = "production" }
}
```

## Useful Links

- [Dagger Go SDK API Reference](https://pkg.go.dev/dagger.io/dagger)
- [Dagger Documentation](https://docs.dagger.io/llms.txt)
